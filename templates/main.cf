# Do not say that we are Postfix
smtpd_banner = $myhostname ESMTP server there, my friend
# Transform 'user' to 'user@<domain>' when connect and send
myorigin = {{ mail_domain }}

mynetworks = 127.0.0.0/8
# There is *NO* local system users to get an email. Only virtuals, so
# 'mydomain' is set to invalid
mydomain = $myorigin
#mydestination = $mydomain, $myhostname, localhost
# It is blank as we using only virtual domains
mydestination =
# Not define how to store emails, our IMAP server will do that
#virtual_transport = lmtp:unix:/var/lib/imap/socket/lmtp
virtual_transport = dovecot
# Aliases for which we can forward emails
virtual_alias_maps = mysql:/etc/postfix/virtual_aliases.cf
# There are real domains for which we will accept emails
virtual_mailbox_domains = mysql:/etc/postfix/virtual_domains.cf
# And there are users of these domains which are stored in MySQL
virtual_mailbox_maps = mysql:/etc/postfix/virtual_mailboxes.cf
# Uid of mail user and its group
virtual_minimum_uid = 5000
virtual_uid_maps = static:5000
virtual_gid_maps = static:5000
# Base for mails
virtual_mailbox_base = /var/mail/vhosts


# Enable SASL (SMTP auth)
smtpd_sasl_auth_enable = yes
# No AUTH to anonymous (no answer 'ok' to any data)
# Also no AUTH for sending user/pass plaintext
smtpd_sasl_security_options = noanonymous, noplaintext
# But AUTH for plaintext over TLS (it is ok)
smtpd_sasl_tls_security_options = noanonymous
{% if mail_ssl_enabled %}
# And no AUTH without TLS
smtpd_tls_auth_only = yes
{% endif %}
# If client not give us a realm, set this by default
#smtpd_sasl_local_domain = $mydomain
# Sasl auth via dovecot
smtpd_sasl_type = dovecot
smtpd_sasl_path = private/auth
# Use both 'AUTH-' and 'AUTH='
broken_sasl_auth_clients = yes

# Always use TLS for incoming connections
smtpd_use_tls = yes
{% if mail_ssl_enabled %}
# TLS certificate. Must be in PEM format. Can be world-readable
# If cert contains intermediate CA certs, they must be placed after server
# cert.
smtpd_tls_cert_file = /etc/letsencrypt/live/{{ mail_hostname }}/fullchain.pem
# TLS private key. Must be in PEM format too. Should be root:root rw-------
smtpd_tls_key_file = /etc/letsencrypt/live/{{ mail_hostname }}/privkey.pem
{% endif %}
# TLS encryption may means it not required
# smtP_tls* is for postfix-MTA. It means that this postfix will try to encrypt
# a connection to the server it will send an email
smtp_tls_security_level = may
# smtpD_tls* is for MTA-postfix. It means our client can try to encrypt a
# connection to this postfix to send an email to it.
smtpd_tls_security_level = may
# So, a bit about what is does *really* mean. smtp_tls_security_level set to
# 'may' means that this postfix will always try to establish TLS connection to
# services to which it tries *send* messages. 'may' means that if these
# services don't support TLS, postfix will use plaintext.
# smtpd_tls_security_level means that anyone who tries to connect to any
# postfix service (at *any* port), *may try* to establish TLS connection to
# postfix before send their messages. So, postfix will still listen on port 25
# (most MTAs will try to establish a connection to it) and on port 587 (most
# clients will try to establish a secure connection to it). *But* you can
# override this value in master.cf config file for separate services. E.g. if
# you will set '-o smtpd_tls_security_level=encrypt' to 'submission' service,
# then all the clients who try to connect to the port 587 now *must* use TLS
# to use that port at all.

# So, for now we have accept only TLS connections on 587
# port and accept both plaintext and TLS on 25 port. You can
# check it by issue next command:
# openssl s_client -debug -starttls smtp -crlf -connect <your MX server>:587

#mailbox_transport = lmtp:unix:/var/lib/imap/socket/lmtp

#smtpd_relay_restrictions =
#        permit_mynetworks
#        permit_sasl_authenticated
#        reject_unauth_destination

# spam restrictions
disable_vrfy_command = yes
smtpd_delay_reject = yes
 # We will DENY empty HELO when client connects
smtpd_helo_required = yes

smtpd_helo_restrictions =
        permit_sasl_authenticated,
        reject_non_fqdn_sender,
        reject_invalid_hostname,
	      reject_invalid_helo_hostname,
        reject_non_fqdn_hostname,
	      reject_non_fqdn_helo_hostname,
        reject_unknown_hostname,
	      reject_unknown_helo_hostname,
        permit_mynetworks,
        permit

smtpd_sender_restrictions =
        permit_sasl_authenticated,
        reject_non_fqdn_sender,
        reject_unknown_sender_domain,
	      reject_unverified_sender,
        permit

smtpd_recipient_restrictions =
        permit_mynetworks,
        permit_sasl_authenticated,
        reject_non_fqdn_recipient,
        reject_unauth_pipelining,
        reject_unknown_recipient_domain,
        reject_unauth_destination,
        reject_unverified_recipient,
        {% if check_policy['enabled'] %}
	      check_policy_service inet:{{ check_policy['address'] }}:{{ check_policy['port'] }}
        {% endif %}
        reject_invalid_hostname,
        permit

smtpd_client_restrictions =
        permit_mynetworks,
# We are use external spam rejector, but save there
# a list of rbl lists just in case
#        reject_rbl_client list.dsbl.org,
#        reject_rbl_client bl.spamcop.net,
#        reject_rbl_client cbl.abuseat.org,
#        reject_rbl_client psbl.surriel.com,
#        reject_rbl_client spamsources.fabel.dk,
#        reject_rbl_client opm.blitzed.org,
#        reject_rbl_client combined.njabl.org,
#        reject_rbl_client dul.ru,
#        reject_rbl_client dialup.balcklist.jippg.org,
#        reject_rbl_client relays.mail-abuse.org,
#        reject_rbl_client dnsbl.sorbs.net,
        reject_unknown_client,
        permit


unknown_local_recipient_reject_code = 550

{% if dkim['enabled'] %}
# Enable DKIM signing
milter_default_action = accept
milter_protocol = 2
smtpd_milters = inet:{{ dkim['milter_address'] }}:{{ dkim['milter_port'] }}
non_smtpd_milters = inet:{{ dkim['milter_address'] }}:{{ dkim['milter_port'] }}
{% endif %}

# Disable IPv6
inet_protocols = ipv4
